{"version":3,"file":"unify-mp3-timing-BniELK9l.js","sources":["../../node_modules/unify-mp3-timing/lib/lib.js","../../node_modules/unify-mp3-timing/lib/id3v2.js","../../node_modules/unify-mp3-timing/lib/xing.js","../../node_modules/unify-mp3-timing/main.js"],"sourcesContent":["//     mp3-parser/lib v0.3.0\r\n\r\n//     https://github.com/biril/mp3-parser\r\n//     Licensed and freely distributed under the MIT License\r\n//     Copyright (c) 2013-2016 Alex Lambiris\r\n\r\n// ----\r\n\r\n/* jshint browser:true */\r\n/* global exports:false, define:false */\r\n(function (globalObject, createModule) {\r\n    \"use strict\";\r\n\r\n    // Export as a module or global depending on environment:\r\n\r\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\r\n    if (typeof define === \"function\" && define.amd) {\r\n        return define([\"exports\"], createModule);\r\n    }\r\n\r\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\r\n    if (typeof exports === \"object\") { return createModule(exports); }\r\n\r\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\r\n    var previousMp3ParserLib = globalObject.mp3ParserLib;\r\n    createModule(globalObject.mp3ParserLib = {\r\n        noConflict: function () {\r\n            var lib = globalObject.mp3ParserLib;\r\n            globalObject.mp3ParserLib = previousMp3ParserLib;\r\n            return (this.noConflict = function () { return lib; }).call();\r\n        }\r\n    });\r\n}(this, function (lib) {\r\n    \"use strict\";\r\n\r\n    // Produce octet's binary representation as a string\r\n    var octetToBinRep = (function () {\r\n        var b = []; // The binary representation\r\n        return function (octet) {\r\n            b[0] = ((octet & 128) === 128 ? \"1\" : \"0\");\r\n            b[1] = ((octet & 64)  === 64  ? \"1\" : \"0\");\r\n            b[2] = ((octet & 32)  === 32  ? \"1\" : \"0\");\r\n            b[3] = ((octet & 16)  === 16  ? \"1\" : \"0\");\r\n            b[4] = ((octet & 8)   === 8   ? \"1\" : \"0\");\r\n            b[5] = ((octet & 4)   === 4   ? \"1\" : \"0\");\r\n            b[6] = ((octet & 2)   === 2   ? \"1\" : \"0\");\r\n            b[7] = ((octet & 1)   === 1   ? \"1\" : \"0\");\r\n            return b.join(\"\");\r\n        };\r\n    }());\r\n\r\n    // Get the number of bytes in a frame given its `bitrate`, `samplingRate` and `padding`.\r\n    //  Based on [magic formula](http://mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm)\r\n    lib.getFrameByteLength = function (kbitrate, samplingRate, padding, mpegVersion, layerVersion) {\r\n        var sampleLength = lib.sampleLengthMap[mpegVersion][layerVersion];\r\n        var paddingSize = padding ? (layerVersion === \"11\" ? 4 : 1) : 0;\r\n        var byteRate = kbitrate * 1000 / 8;\r\n        return Math.floor((sampleLength * byteRate / samplingRate) + paddingSize);\r\n    };\r\n\r\n    lib.getXingOffset = function (mpegVersion, channelMode) {\r\n        var mono = channelMode === \"11\";\r\n        if (mpegVersion === \"11\") { // mpeg1\r\n            return mono ? 21 : 36;\r\n        } else {\r\n            return mono ? 13 : 21;\r\n        }\r\n    };\r\n\r\n    //\r\n    lib.v1l1Bitrates = {\r\n        \"0000\": \"free\",\r\n        \"0001\": 32,\r\n        \"0010\": 64,\r\n        \"0011\": 96,\r\n        \"0100\": 128,\r\n        \"0101\": 160,\r\n        \"0110\": 192,\r\n        \"0111\": 224,\r\n        \"1000\": 256,\r\n        \"1001\": 288,\r\n        \"1010\": 320,\r\n        \"1011\": 352,\r\n        \"1100\": 384,\r\n        \"1101\": 416,\r\n        \"1110\": 448,\r\n        \"1111\": \"bad\"\r\n    };\r\n\r\n    //\r\n    lib.v1l2Bitrates = {\r\n        \"0000\": \"free\",\r\n        \"0001\": 32,\r\n        \"0010\": 48,\r\n        \"0011\": 56,\r\n        \"0100\": 64,\r\n        \"0101\": 80,\r\n        \"0110\": 96,\r\n        \"0111\": 112,\r\n        \"1000\": 128,\r\n        \"1001\": 160,\r\n        \"1010\": 192,\r\n        \"1011\": 224,\r\n        \"1100\": 256,\r\n        \"1101\": 320,\r\n        \"1110\": 384,\r\n        \"1111\": \"bad\"\r\n    };\r\n\r\n    //\r\n    lib.v1l3Bitrates = {\r\n        \"0000\": \"free\",\r\n        \"0001\": 32,\r\n        \"0010\": 40,\r\n        \"0011\": 48,\r\n        \"0100\": 56,\r\n        \"0101\": 64,\r\n        \"0110\": 80,\r\n        \"0111\": 96,\r\n        \"1000\": 112,\r\n        \"1001\": 128,\r\n        \"1010\": 160,\r\n        \"1011\": 192,\r\n        \"1100\": 224,\r\n        \"1101\": 256,\r\n        \"1110\": 320,\r\n        \"1111\": \"bad\"\r\n    };\r\n\r\n    //\r\n    lib.v2l1Bitrates = {\r\n        \"0000\": \"free\",\r\n        \"0001\": 32,\r\n        \"0010\": 48,\r\n        \"0011\": 56,\r\n        \"0100\": 64,\r\n        \"0101\": 80,\r\n        \"0110\": 96,\r\n        \"0111\": 112,\r\n        \"1000\": 128,\r\n        \"1001\": 144,\r\n        \"1010\": 160,\r\n        \"1011\": 176,\r\n        \"1100\": 192,\r\n        \"1101\": 224,\r\n        \"1110\": 256,\r\n        \"1111\": \"bad\"\r\n    };\r\n\r\n    //\r\n    lib.v2l2Bitrates = {\r\n        \"0000\": \"free\",\r\n        \"0001\": 8,\r\n        \"0010\": 16,\r\n        \"0011\": 24,\r\n        \"0100\": 32,\r\n        \"0101\": 40,\r\n        \"0110\": 48,\r\n        \"0111\": 56,\r\n        \"1000\": 64,\r\n        \"1001\": 80,\r\n        \"1010\": 96,\r\n        \"1011\": 112,\r\n        \"1100\": 128,\r\n        \"1101\": 144,\r\n        \"1110\": 160,\r\n        \"1111\": \"bad\"\r\n    };\r\n    lib.v2l3Bitrates = lib.v2l2Bitrates;\r\n\r\n    //\r\n    lib.v1SamplingRates = {\r\n        \"00\": 44100,\r\n        \"01\": 48000,\r\n        \"10\": 32000,\r\n        \"11\": \"reserved\"\r\n    };\r\n\r\n    //\r\n    lib.v2SamplingRates = {\r\n        \"00\": 22050,\r\n        \"01\": 24000,\r\n        \"10\": 16000,\r\n        \"11\": \"reserved\"\r\n    };\r\n\r\n    //\r\n    lib.v25SamplingRates = {\r\n        \"00\": 11025,\r\n        \"01\": 12000,\r\n        \"10\": 8000,\r\n        \"11\": \"reserved\"\r\n    };\r\n\r\n    //\r\n    lib.channelModes = {\r\n        \"00\": \"Stereo\",\r\n        \"01\": \"Joint stereo (Stereo)\",\r\n        \"10\": \"Dual channel (Stereo)\",\r\n        \"11\": \"Single channel (Mono)\"\r\n    };\r\n\r\n    //\r\n    lib.mpegVersionDescription = {\r\n        \"00\": \"MPEG Version 2.5 (unofficial)\",\r\n        \"01\": \"reserved\",\r\n        \"10\": \"MPEG Version 2 (ISO/IEC 13818-3)\",\r\n        \"11\": \"MPEG Version 1 (ISO/IEC 11172-3)\"\r\n    };\r\n\r\n    //\r\n    lib.layerDescription = {\r\n        \"00\": \"reserved\",\r\n        \"01\": \"Layer III\",\r\n        \"10\": \"Layer II\",\r\n        \"11\": \"Layer I\"\r\n    };\r\n\r\n    //\r\n    lib.bitrateMap = {\r\n        \"11\": {\r\n            \"01\": lib.v1l3Bitrates,\r\n            \"10\": lib.v1l2Bitrates,\r\n            \"11\": lib.v1l1Bitrates\r\n        },\r\n        \"10\": {\r\n            \"01\": lib.v2l3Bitrates,\r\n            \"10\": lib.v2l2Bitrates,\r\n            \"11\": lib.v2l1Bitrates\r\n        }\r\n    };\r\n\r\n    //\r\n    lib.samplingRateMap = {\r\n        \"00\": lib.v25SamplingRates,\r\n        \"10\": lib.v2SamplingRates,\r\n        \"11\": lib.v1SamplingRates\r\n    };\r\n\r\n    //\r\n    lib.v1SampleLengths = {\r\n        \"01\": 1152,\r\n        \"10\": 1152,\r\n        \"11\": 384\r\n    };\r\n\r\n    //\r\n    lib.v2SampleLengths = {\r\n        \"01\": 576,\r\n        \"10\": 1152,\r\n        \"11\": 384\r\n    };\r\n\r\n    //\r\n    lib.sampleLengthMap = {\r\n        \"01\": lib.v2SampleLengths,\r\n        \"10\": lib.v2SampleLengths,\r\n        \"11\": lib.v1SampleLengths\r\n    };\r\n\r\n    // Convert the given string `str` to an array of words (octet pairs). If all characters in the\r\n    //  given string are within the ISO/IEC 8859-1 subset then the returned array may safely be\r\n    //  interpreted as an array of values in the [0, 255] range, where each value requires a single\r\n    //  octet to be represented. Otherwise it should be interpreted as an array of values in the\r\n    //  [0, 65.535] range, where each value requires a word (octet pair) to be represented.\r\n    //\r\n    // Not meant to be used with UTF-16 strings that contain chars outside the BMP. See\r\n    //  [charCodeAt on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)\r\n    lib.wordSeqFromStr = function (str) {\r\n        for (var i = str.length - 1, seq = []; i >= 0; --i) {\r\n            seq[i] = str.charCodeAt(i);\r\n        }\r\n        return seq;\r\n    };\r\n\r\n    // Common character sequences converted to byte arrays\r\n    lib.seq = {\r\n        id3: lib.wordSeqFromStr(\"ID3\"),\r\n        xing: lib.wordSeqFromStr(\"Xing\"),\r\n        info: lib.wordSeqFromStr(\"Info\")\r\n    };\r\n\r\n    // A handy no-op to reuse\r\n    lib.noOp = function () {};\r\n\r\n    // Decode a [synchsafe](http://en.wikipedia.org/wiki/Synchsafe) value. Synchsafes are used in\r\n    //  ID3 tags, instead of regular ints, to avoid the unintended introduction of bogus\r\n    //  frame-syncs. Note that the spec requires that syncsafe be always stored in big-endian order\r\n    //  (Implementation shamefully lifted from relevant wikipedia article)\r\n    lib.unsynchsafe = function (value) {\r\n        var out = 0;\r\n        var mask = 0x7F000000;\r\n\r\n        while (mask) {\r\n            out >>= 1;\r\n            out |= value & mask;\r\n            mask >>= 8;\r\n        }\r\n\r\n        return out;\r\n    };\r\n\r\n    // Get a value indicating whether given DataView `view` contains the `seq` sequence (array\r\n    //  of octets) at `offset` index. Note that no check is performed for the adequate length of\r\n    //  given view as this should be carried out by the caller\r\n    lib.isSeq = function (seq, view, offset) {\r\n        for (var i = seq.length - 1; i >= 0; i--) {\r\n            if (seq[i] !== view.getUint8(offset + i)) { return false; }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    // Get a value indicating whether given DataView `view` contains the `str` string\r\n    //  at `offset` index. The view is parsed as an array of 8bit single-byte coded characters\r\n    //  (i.e. ISO/IEC 8859-1, _non_ Unicode). Will return the string itself if it does, false\r\n    //  otherwise. Note that no check is performed for the adequate length of given view as\r\n    //  this should be carried out be the caller as part of the section-parsing process\r\n    /*\r\n    isStr = function (str, view, offset) {\r\n        return isSeq(lib.wordSeqFromStr(str), view, offset) ? str : false;\r\n    };\r\n    */\r\n\r\n    // Locate first occurrence of sequence `seq` (an array of octets) in DataView `view`.\r\n    //  Search starts at given `offset` and ends after `length` octets. Will return the\r\n    //  absolute offset of sequence if found, -1 otherwise\r\n    lib.locateSeq = function (seq, view, offset, length) {\r\n        for (var i = 0, l = length - seq.length + 1; i < l; ++i) {\r\n            if (lib.isSeq(seq, view, offset + i)) { return offset + i; }\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    lib.locateStrTrm = {\r\n        // Locate the first occurrence of non-Unicode null-terminator (i.e. a single zeroed-out\r\n        //  octet) in DataView `view`. Search starts at given `offset` and ends after `length`\r\n        //  octets. Will return the absolute offset of sequence if found, -1 otherwise\r\n        iso: function (view, offset, length) {\r\n            return lib.locateSeq([0], view, offset, length);\r\n        },\r\n\r\n        // Locate the first occurrence of Unicode null-terminator (i.e. a sequence of two\r\n        //  zeroed-out octets) in DataView `view`. Search starts at given `offset` and ends after\r\n        //  `length` octets. Will return the absolute offset of sequence if found, -1 otherwise\r\n        ucs: function (view, offset, length) {\r\n            var trmOffset = lib.locateSeq([0, 0], view, offset, length);\r\n            if (trmOffset === -1) { return -1; }\r\n            if ((trmOffset - offset) % 2 !== 0) { ++trmOffset; }\r\n            return trmOffset;\r\n        }\r\n    };\r\n\r\n    lib.readStr = {\r\n        // Parse DataView `view` begining at `offset` index and return a string built from\r\n        //  `length` octets. The view is parsed as an array of 8bit single-byte coded characters\r\n        //  (i.e. ISO/IEC 8859-1, _non_ Unicode). Will essentially return the string comprised of\r\n        //  octets [offset, offset + length). Note that no check is performed for the adequate\r\n        //  length of given view as this should be carried out be the caller as part of the\r\n        //  section-parsing process\r\n        iso: function (view, offset, length) {\r\n            return String.fromCharCode.apply(null, new Uint8Array(view.buffer, offset, length));\r\n        },\r\n\r\n        // UCS-2 (ISO/IEC 10646-1:1993, UCS-2) version of `readStr`. UCS-2 is the fixed-width\r\n        //  two-byte subset of Unicode that can only express values inside the Basic Multilingual\r\n        //  Plane (BMP). Note that this method is generally unsuitable for parsing non-trivial\r\n        //  UTF-16 strings which may contain surrogate pairs. [This is only marginally related\r\n        //  though as, according to ID3v2, all Unicode strings should be UCS-2.] Further info:\r\n        //\r\n        //  * [How to convert ArrayBuffer to and from String](http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String)\r\n        //  * [The encoding spec](http://encoding.spec.whatwg.org/)\r\n        //  * [stringencoding shim](https://code.google.com/p/stringencoding/)\r\n        //\r\n        // About the BOM: The current implementation will check for and remove the leading BOM from\r\n        //  the given view to avoid invisible characters that mess up the resulting strings. MDN's\r\n        //  documentation for [fromCharCode](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)\r\n        //  suggests that it can correctly convert UCS-2 buffers to strings. And indeed, tests\r\n        //  performed with UCS-2 LE encoded frames indicate that it does. However, no tests have\r\n        //  been made for UCS-2 BE. (Kid3, the ID3v2 Tag generator used for tests at the time of\r\n        //  this writing, goes totally weird when switched to BE)\r\n        ucs: function (view, offset, length) {\r\n            // Tweak offset to remove the BOM (LE: FF FE / BE: FE FF)\r\n            if (view.getUint16(offset) === 0xFFFE || view.getUint16(offset) === 0xFEFF) {\r\n                offset += 2;\r\n                length -= 2;\r\n            }\r\n\r\n            var buffer = view.buffer;\r\n\r\n            // When offset happens to be an even number of octets, the array-buffer may be wrapped\r\n            //  in a Uint16Array. In the event that it's _not_, an actual copy has to be made\r\n            // (Note that Node <= 0.8 as well as IE <= 10 lack an ArrayBuffer#slice. TODO: shim it)\r\n            if (offset % 2 === 1) {\r\n                buffer = buffer.slice(offset, offset + length);\r\n                offset = 0;\r\n            }\r\n\r\n            return String.fromCharCode.apply(null, new Uint16Array(buffer, offset, length / 2));\r\n        }\r\n    };\r\n\r\n    lib.readTrmStr = {\r\n        // Similar to `readStr.iso` but will check for a null-terminator determining the end of the\r\n        //  string. The returned string will be of _at most_ `length` octets\r\n        iso: function (view, offset, length) {\r\n            var trmOffset = lib.locateStrTrm.iso(view, offset, length);\r\n            if (trmOffset !== -1) { length = trmOffset - offset; }\r\n            return lib.readStr.iso(view, offset, length);\r\n        },\r\n\r\n        // Similar to `readStr.ucs` but will check for a null-terminator determining the end of the\r\n        //  string. The returned string will be of _at most_ `length` octets\r\n        ucs: function (view, offset, length) {\r\n            var trmOffset = lib.locateStrTrm.ucs(view, offset, length);\r\n            if (trmOffset !== -1) { length = trmOffset - offset; }\r\n            return lib.readStr.ucs(view, offset, length);\r\n        }\r\n    };\r\n\r\n    // ### Read a Frame Header\r\n    //\r\n    // Read header of frame located at `offset` of DataView `view`. Returns null in the event\r\n    //  that no frame header is found at `offset`\r\n    lib.readFrameHeader = function (view, offset) {\r\n        offset || (offset = 0);\r\n\r\n        // There should be more than 4 octets ahead\r\n        if (view.byteLength - offset <= 4) { return null; }\r\n\r\n        // Header's first (out of four) octet: `11111111`: Frame sync (all bits must be set)\r\n        var b1 = view.getUint8(offset);\r\n        if (b1 !== 255) { return null; }\r\n\r\n        // Header's second (out of four) octet: `111xxxxx`\r\n        //\r\n        // * `111.....`: Rest of frame sync (all bits must be set)\r\n        // * `...BB...`: MPEG Audio version ID (11 -> MPEG Version 1 (ISO/IEC 11172-3))\r\n        // * `.....CC.`: Layer description (01 -> Layer III)\r\n        // * `.......1`: Protection bit (1 = Not protected)\r\n\r\n        // Require the three most significant bits to be `111` (>= 224)\r\n        var b2 = view.getUint8(offset + 1);\r\n        if (b2 < 224) { return null; }\r\n\r\n        var mpegVersion = octetToBinRep(b2).substr(3, 2);\r\n        var layerVersion = octetToBinRep(b2).substr(5, 2);\r\n\r\n        //\r\n        var header = {\r\n            _section: { type: \"frameHeader\", byteLength: 4, offset: offset },\r\n            mpegAudioVersionBits: mpegVersion,\r\n            mpegAudioVersion: lib.mpegVersionDescription[mpegVersion],\r\n            layerDescriptionBits: layerVersion,\r\n            layerDescription: lib.layerDescription[layerVersion],\r\n            isProtected: b2 & 1, // Just check if last bit is set\r\n        };\r\n        header.protectionBit = header.isProtected ? \"1\" : \"0\";\r\n\r\n        if (header.mpegAudioVersion === \"reserved\") { return null; }\r\n        if (header.layerDescription === \"reserved\") { return null; }\r\n\r\n        // Header's third (out of four) octet: `EEEEFFGH`\r\n        //\r\n        // * `EEEE....`: Bitrate index. 1111 is invalid, everything else is accepted\r\n        // * `....FF..`: Sampling rate, 00=44100, 01=48000, 10=32000, 11=reserved\r\n        // * `......G.`: Padding bit, 0=frame not padded, 1=frame padded\r\n        // * `.......H`: Private bit. This is informative\r\n        var b3 = view.getUint8(offset + 2);\r\n        b3 = octetToBinRep(b3);\r\n        header.bitrateBits = b3.substr(0, 4);\r\n        header.bitrate = lib.bitrateMap[mpegVersion][layerVersion][header.bitrateBits];\r\n        if (header.bitrate === \"bad\") { return null; }\r\n\r\n        header.samplingRateBits = b3.substr(4, 2);\r\n        header.samplingRate = lib.samplingRateMap[mpegVersion][header.samplingRateBits];\r\n        if (header.samplingRate === \"reserved\") { return null; }\r\n\r\n        header.frameIsPaddedBit = b3.substr(6, 1);\r\n        header.frameIsPadded = header.frameIsPaddedBit === \"1\";\r\n        header.framePadding = header.frameIsPadded ? 1 : 0;\r\n\r\n        header.privateBit = b3.substr(7, 1);\r\n\r\n        // Header's fourth (out of four) octet: `IIJJKLMM`\r\n        //\r\n        // * `II......`: Channel mode\r\n        // * `..JJ....`: Mode extension (only if joint stereo)\r\n        // * `....K...`: Copyright\r\n        // * `.....L..`: Original\r\n        // * `......MM`: Emphasis\r\n        var b4 = view.getUint8(offset + 3);\r\n        header.channelModeBits = octetToBinRep(b4).substr(0, 2);\r\n        header.channelMode = lib.channelModes[header.channelModeBits];\r\n\r\n        return header;\r\n    };\r\n\r\n    // ### Read a Frame\r\n    //\r\n    // Read frame located at `offset` of DataView `view`. Will acquire the frame header (see\r\n    //  `readFrameHeader`) plus some basic information about the frame - notably the frame's length\r\n    //  in bytes. If `requireNextFrame` is set, the presence of a _next_ valid frame will be\r\n    //  required for _this_ frame to be regarded as valid. Returns null in the event that no frame\r\n    //  is found at `offset`\r\n    lib.readFrame = function (view, offset, requireNextFrame) {\r\n        offset || (offset = 0);\r\n\r\n        var frame = {\r\n            _section: { type: \"frame\", offset: offset },\r\n            header: lib.readFrameHeader(view, offset)\r\n        };\r\n\r\n        var head = frame.header; // Convenience shortcut\r\n\r\n        // Frame should always begin with a valid header\r\n        if (!head) { return null; }\r\n\r\n        frame._section.sampleLength =\r\n            lib.sampleLengthMap[head.mpegAudioVersionBits][head.layerDescriptionBits];\r\n\r\n        //\r\n        frame._section.byteLength = lib.getFrameByteLength(head.bitrate, head.samplingRate,\r\n            head.framePadding, head.mpegAudioVersionBits, head.layerDescriptionBits);\r\n        frame._section.nextFrameIndex = offset + frame._section.byteLength;\r\n\r\n        // No \"Xing\" or \"Info\" identifier should be present - this would indicate that this\r\n        //  is in fact a Xing tag masquerading as a frame\r\n        var xingOffset = lib.getXingOffset(head.mpegAudioVersionBits, head.channelModeBits);\r\n        if (lib.isSeq(lib.seq.xing, view, offset + xingOffset) ||\r\n            lib.isSeq(lib.seq.info, view, offset + xingOffset)) {\r\n            return null;\r\n        }\r\n\r\n        // If a next frame is required then the data at `frame._section.nextFrameIndex` should be\r\n        //  a valid frame header\r\n        if (requireNextFrame && !lib.readFrameHeader(view, frame._section.nextFrameIndex)) {\r\n            return null;\r\n        }\r\n\r\n        return frame;\r\n    };\r\n}));\r\n","//     mp3-parser/id3v2 v0.3.0\r\n\r\n//     https://github.com/biril/mp3-parser\r\n//     Licensed and freely distributed under the MIT License\r\n//     Copyright (c) 2013-2016 Alex Lambiris\r\n\r\n// ----\r\n\r\n/* jshint browser:true */\r\n/* global exports:false, define:false, require:false */\r\n(function (globalObject, createModule) {\r\n    \"use strict\";\r\n\r\n    // Export as a module or global depending on environment:\r\n\r\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\r\n    if (typeof define === \"function\" && define.amd) {\r\n        return define([\"exports\", \"./lib\"], createModule);\r\n    }\r\n\r\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\r\n    if (typeof exports === \"object\") {\r\n        return createModule(exports, require(\"./lib\"));\r\n    }\r\n\r\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\r\n    var previousMp3Id3v2Parser = globalObject.mp3Id3v2Parser;\r\n    createModule(globalObject.mp3Id3v2Parser = {\r\n        noConflict: function () {\r\n            var mp3Id3v2Parser = globalObject.mp3Id3v2Parser;\r\n            globalObject.mp3Id3v2Parser = previousMp3Id3v2Parser;\r\n            return (this.noConflict = function () { return mp3Id3v2Parser; }).call();\r\n        }\r\n    }, globalObject.mp3ParserLib);\r\n}(this, function (mp3Id3v2Parser, lib) {\r\n    \"use strict\";\r\n\r\n    //\r\n    var id3v2TagFrameNames = {\r\n        AENC: \"Audio encryption\",\r\n        APIC: \"Attached picture\",\r\n        CHAP: \"Chapter\",\r\n        COMM: \"Comments\",\r\n        COMR: \"Commercial frame\",\r\n        ENCR: \"Encryption method registration\",\r\n        EQUA: \"Equalization\",\r\n        ETCO: \"Event timing codes\",\r\n        GEOB: \"General encapsulated object\",\r\n        GRID: \"Group identification registration\",\r\n        IPLS: \"Involved people list\",\r\n        LINK: \"Linked information\",\r\n        MCDI: \"Music CD identifier\",\r\n        MLLT: \"MPEG location lookup table\",\r\n        OWNE: \"Ownership frame\",\r\n        PRIV: \"Private frame\",\r\n        PCNT: \"Play counter\",\r\n        POPM: \"Popularimeter\",\r\n        POSS: \"Position synchronisation frame\",\r\n        RBUF: \"Recommended buffer size\",\r\n        RVAD: \"Relative volume adjustment\",\r\n        RVRB: \"Reverb\",\r\n        SYLT: \"Synchronized lyric/text\",\r\n        SYTC: \"Synchronized tempo codes\",\r\n        TALB: \"Album/Movie/Show title\",\r\n        TBPM: \"BPM (beats per minute)\",\r\n        TCOM: \"Composer\",\r\n        TCON: \"Content type\",\r\n        TCOP: \"Copyright message\",\r\n        TDAT: \"Date\",\r\n        TDLY: \"Playlist delay\",\r\n        TENC: \"Encoded by\",\r\n        TEXT: \"Lyricist/Text writer\",\r\n        TFLT: \"File type\",\r\n        TIME: \"Time\",\r\n        TIT1: \"Content group description\",\r\n        TIT2: \"Title/songname/content description\",\r\n        TIT3: \"Subtitle/Description refinement\",\r\n        TKEY: \"Initial key\",\r\n        TLAN: \"Language(s)\",\r\n        TLEN: \"Length\",\r\n        TMED: \"Media type\",\r\n        TOAL: \"Original album/movie/show title\",\r\n        TOFN: \"Original filename\",\r\n        TOLY: \"Original lyricist(s)/text writer(s)\",\r\n        TOPE: \"Original artist(s)/performer(s)\",\r\n        TORY: \"Original release year\",\r\n        TOWN: \"File owner/licensee\",\r\n        TPE1: \"Lead performer(s)/Soloist(s)\",\r\n        TPE2: \"Band/orchestra/accompaniment\",\r\n        TPE3: \"Conductor/performer refinement\",\r\n        TPE4: \"Interpreted, remixed, or otherwise modified by\",\r\n        TPOS: \"Part of a set\",\r\n        TPUB: \"Publisher\",\r\n        TRCK: \"Track number/Position in set\",\r\n        TRDA: \"Recording dates\",\r\n        TRSN: \"Internet radio station name\",\r\n        TRSO: \"Internet radio station owner\",\r\n        TSIZ: \"Size\",\r\n        TSRC: \"ISRC (international standard recording code)\",\r\n        TSSE: \"Software/Hardware and settings used for encoding\",\r\n        TYER: \"Year\",\r\n        TXXX: \"User defined text information frame\",\r\n        UFID: \"Unique file identifier\",\r\n        USER: \"Terms of use\",\r\n        USLT: \"Unsychronized lyric/text transcription\",\r\n        WCOM: \"Commercial information\",\r\n        WCOP: \"Copyright/Legal information\",\r\n        WOAF: \"Official audio file webpage\",\r\n        WOAR: \"Official artist/performer webpage\",\r\n        WOAS: \"Official audio source webpage\",\r\n        WORS: \"Official internet radio station homepage\",\r\n        WPAY: \"Payment\",\r\n        WPUB: \"Publishers official webpage\",\r\n        WXXX: \"User defined URL link frame\"\r\n    };\r\n\r\n    //\r\n    var readFrameContent = {};\r\n\r\n    // Read the content of a\r\n    //  [text-information frame](http://id3.org/id3v2.3.0#Text_information_frames). These are\r\n    //  common and contain info such as artist and album. There may only be one text info frame\r\n    //  of its kind in a tag. If the textstring is followed by a termination (00) all the\r\n    //  following information should be ignored and not be displayed. All text frame\r\n    //  identifiers begin with \"T\". Only text frame identifiers begin with \"T\", with the\r\n    //  exception of the \"TXXX\" frame\r\n    //\r\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\r\n    // * Information: a text string according to encoding\r\n    readFrameContent.T = function (view, offset, length) {\r\n        var content = { encoding: view.getUint8(offset) };\r\n        content.value = lib.readStr[content.encoding === 0 ? \"iso\" : \"ucs\"](\r\n            view, offset + 1, length - 1);\r\n        return content;\r\n    };\r\n\r\n    // Read the content of a\r\n    //  [user-defined text-information frame](http://id3.org/id3v2.3.0#User_defined_text_information_frame).\r\n    //  Intended for one-string text information concerning the audiofile in a similar way to\r\n    //  the other \"T\"-frames. The frame body consists of a description of the string,\r\n    //  represented as a terminated string, followed by the actual string. There may be more\r\n    //  than one \"TXXX\" frame in each tag, but only one with the same description\r\n    //\r\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\r\n    // * Description: a text string according to encoding (followed by 00 (00))\r\n    // * Value:       a text string according to encoding\r\n    readFrameContent.TXXX = function  (view, offset, length) {\r\n        // The content to be returned\r\n        var content = { encoding: view.getUint8(offset) };\r\n\r\n        // Encoding + null term. = at least 2 octets\r\n        if (length < 2) {\r\n            return content; // Inadequate length!\r\n        }\r\n\r\n        // Encoding and content beginning (description field)\r\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\r\n        var offsetBeg = offset + 1;\r\n\r\n        // Locate the the null terminator seperating description and URL\r\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\r\n        if (offsetTrm === -1) {\r\n            return content; // Not found!\r\n        }\r\n\r\n        // Read description and value data into content\r\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\r\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\r\n        content.value = lib.readStr[enc](view, offsetTrm, offset + length - offsetTrm);\r\n\r\n        return content;\r\n    };\r\n\r\n    // Read the content of a\r\n    //  [URL-link frame](http://id3.org/id3v2.3.0#URL_link_frames). There may only be one\r\n    //  URL link frame of its kind in a tag, except when stated otherwise in the frame\r\n    //  description. If the textstring is followed by a termination (00) all the following\r\n    //  information should be ignored and not be displayed. All URL link frame identifiers\r\n    //  begins with \"W\". Only URL link frame identifiers begins with \"W\"\r\n    //\r\n    // * URL: a text string\r\n    readFrameContent.W = function (view, offset, length) {\r\n        return { value: lib.readStr.iso(view, offset, length) };\r\n    };\r\n\r\n    // Read the content of a\r\n    //  [user-defined URL-link frame](http://id3.org/id3v2.3.0#User_defined_URL_link_frame).\r\n    //  Intended for URL links concerning the audiofile in a similar way to the other\r\n    //  \"W\"-frames. The frame body consists of a description of the string, represented as a\r\n    //  terminated string, followed by the actual URL. The URL is always encoded with\r\n    //  ISO-8859-1. There may be more than one \"WXXX\" frame in each tag, but only one with the\r\n    //  same description\r\n    //\r\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\r\n    // * Description: a text string according to encoding (followed by 00 (00))\r\n    // * URL:         a text string\r\n    readFrameContent.WXXX = function (view, offset, length) {\r\n        // The content to be returned\r\n        var content = { encoding: view.getUint8(offset) };\r\n\r\n        // Encoding + null term. = at least 2 octets\r\n        if (length < 2) {\r\n            return content; // Inadequate length!\r\n        }\r\n\r\n        // Encoding and content beginning (description field)\r\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\r\n        var offsetBeg = offset + 1;\r\n\r\n        // Locate the the null terminator seperating description and URL\r\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\r\n        if (offsetTrm === -1) {\r\n            return content; // Not found!\r\n        }\r\n\r\n        // Read description and value data into content\r\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\r\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\r\n        content.value = lib.readStr.iso(view, offsetTrm, offset + length - offsetTrm);\r\n\r\n        return content;\r\n    };\r\n\r\n    // Read the content of a [comment frame](http://id3.org/id3v2.3.0#Comments).\r\n    //  Intended for any kind of full text information that does not fit in any other frame.\r\n    //  Consists of a frame header followed by encoding, language and content descriptors and\r\n    //  ends with the actual comment as a text string. Newline characters are allowed in the\r\n    //  comment text string. There may be more than one comment frame in each tag, but only one\r\n    //  with the same language and content descriptor. [Note that the structure of comment\r\n    //  frames is identical to that of USLT frames - `readFrameContentComm` will handle both.]\r\n    //\r\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\r\n    // * Language:    3 digit (octet) lang-code (ISO-639-2)\r\n    // * Short descr: a text string according to encoding (followed by 00 (00))\r\n    // * Actual text: a text string according to encoding\r\n    readFrameContent.COMM = function (view, offset, length) {\r\n        // The content to be returned\r\n        var content = { encoding: view.getUint8(offset) };\r\n\r\n        // Encoding + language + null term. = at least 5 octets\r\n        if (length < 5) {\r\n            return content; // Inadequate length!\r\n        }\r\n\r\n        // Encoding and content beggining (short description field)\r\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\r\n        var offsetBeg = offset + 4;\r\n\r\n        // Read the language field - 3 octets at most\r\n        content.language = lib.readTrmStr.iso(view, offset + 1, 3);\r\n\r\n        // Locate the the null terminator seperating description and text\r\n        var offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, length - 4);\r\n        if (offsetTrm === -1) {\r\n            return content; // Not found!\r\n        }\r\n\r\n        // Read short description and text data into content\r\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\r\n        offsetTrm += enc === \"ucs\" ? 2 : 1; // Move past terminating sequence\r\n        content.text = lib.readStr[enc](view, offsetTrm, offset + length - offsetTrm);\r\n\r\n        return content;\r\n    };\r\n\r\n    // Read the content of a\r\n    //  [unique file identifier frame](http://id3.org/id3v2.3.0#Unique_file_identifier). Allows\r\n    //  identification of the audio file by means of some database that may contain more\r\n    //  information relevant to the content. Begins with a URL containing an email address, or\r\n    //  a link to a location where an email address can be found that belongs to the\r\n    //  organisation responsible for this specific database implementation. The 'Owner\r\n    //  identifier' must be non-empty (more than just a termination) and is followed by the\r\n    //  actual identifier, which may be up to 64 bytes. There may be more than one \"UFID\" frame\r\n    //  in a tag, but only one with the same 'Owner identifier'. Note that this frame is very\r\n    //  similar to the \"PRIV\" frame\r\n    //\r\n    // * Owner identifier: a text string (followed by 00)\r\n    // * Identifier:       up to 64 bytes of binary data\r\n    readFrameContent.UFID = function (view, offset, length) {\r\n        // Read up to the first null terminator to get the owner-identifier\r\n        var ownerIdentifier = lib.readTrmStr.iso(view, offset, length);\r\n\r\n        // Figure out the identifier based on frame length vs owner-identifier length\r\n        var identifier = new DataView(view.buffer, offset + ownerIdentifier.length + 1,\r\n            length - ownerIdentifier.length - 1);\r\n\r\n        return { ownerIdentifier: ownerIdentifier, identifier: identifier };\r\n    };\r\n\r\n    // Read the content of an\r\n    //  [involved people list frame](http://id3.org/id3v2.3.0#Involved_people_list). Contains\r\n    //  names of those involved - those contributing to the audio file - and how they were\r\n    //  involved. The body simply contains the first 'involvement' as a terminated string, directly\r\n    //  followed by the first 'involvee' as a terminated string, followed by a second terminated\r\n    //  involvement string and so on. However, in the current implementation the frame's content is\r\n    //  parsed as a collection of strings without any semantics attached. There may only be one\r\n    //  \"IPLS\" frame in each tag\r\n    //\r\n    // * Encoding:            a single octet where 0 = ISO-8859-1, 1 = UCS-2\r\n    // * People list strings: a series of strings, e.g. string 00 (00) string 00 (00) ..\r\n    readFrameContent.IPLS = function (view, offset, length) {\r\n        // The content to be returned\r\n        var content = { encoding: view.getUint8(offset), values: [] };\r\n\r\n        // Encoding and content beginning (people list - specifically, first 'involvement' string)\r\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\r\n        var offsetBeg = offset + 1;\r\n\r\n        // Index of null-terminator found within people list (seperates involvement / involvee)\r\n        var offsetNextStrTrm;\r\n\r\n        while (offsetBeg < offset + length) {\r\n            // We expect all strings within the people list to be null terminated ..\r\n            offsetNextStrTrm = lib.locateStrTrm[enc](view, offsetBeg, length - (offsetBeg - offset));\r\n\r\n            // .. except _perhaps_ the last one. In this case fix the offset at the frame's end\r\n            if (offsetNextStrTrm === -1) {\r\n                offsetNextStrTrm = offset + length;\r\n            }\r\n\r\n            content.values.push(lib.readStr[enc](view, offsetBeg, offsetNextStrTrm - offsetBeg));\r\n            offsetBeg = offsetNextStrTrm + (enc === \"ucs\" ? 2 : 1);\r\n        }\r\n\r\n        return content;\r\n    };\r\n\r\n    // Read the content of a [terms of use frame](http://id3.org/id3v2.3.0#Terms_of_use_frame).\r\n    //  Contains a description of the terms of use and ownership of the file. Newlines are\r\n    //  allowed in the text. There may only be one \"USER\" frame in a tag.\r\n    //\r\n    // * Encoding:    a single octet where 0 = ISO-8859-1, 1 = UCS-2\r\n    // * Language:    3 digit (octet) lang-code (ISO-639-2)\r\n    // * Actual text: a text string according to encoding\r\n    readFrameContent.USER = function (view, offset, length) {\r\n        // The content to be returned\r\n        var content = { encoding: view.getUint8(offset) };\r\n\r\n        // Encoding + language + null term. = at least 5 octets\r\n        if (length < 5) {\r\n            return content; // Inadequate length!\r\n        }\r\n\r\n        // Read the language field - 3 octets at most\r\n        content.language = lib.readTrmStr.iso(view, offset + 1, 3);\r\n\r\n        // Read the text field\r\n        var offsetBeg = offset + 4;\r\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\r\n        content.text = lib.readStr[enc](view, offsetBeg, offset + length - offsetBeg);\r\n\r\n        return content;\r\n    };\r\n\r\n    // Read the content of a\r\n    //  [private frame](http://id3.org/id3v2.3.0#Private_frame). Contains binary data that does\r\n    //  no fit into the other frames. Begins with a URL containing an email address, or\r\n    //  a link to a location where an email address can be found. The 'Owner identifier' must\r\n    //  be non-empty (more than just a termination) and is followed by the actual data. There\r\n    //  may be more than one \"PRIV\" frame in a tag, but only with different contents. Note that\r\n    //  this frame is very similar to the \"UFID\" frame\r\n    //\r\n    // * Owner identifier: a text string (followed by 00)\r\n    // * private data:     binary data (of unbounded length)\r\n    readFrameContent.PRIV = function (view, offset, length) {\r\n        // Read up to the first null terminator to get the owner-identifier\r\n        var ownerIdentifier = lib.readTrmStr.iso(view, offset, length);\r\n\r\n        // Figure out the private data based on frame length vs owner-identifier length\r\n        var privateData = new DataView(view.buffer, offset + ownerIdentifier.length + 1,\r\n            length - ownerIdentifier.length - 1);\r\n\r\n        return { ownerIdentifier: ownerIdentifier, privateData: privateData };\r\n    };\r\n\r\n    // Read the content of a [play counter](http://id3.org/id3v2.3.0#Play_counter). A counter\r\n    //  of the number of times a file has been played. There may only be one \"PCNT\" frame in a\r\n    //  tag. [According to the standard, \"When the counter reaches all one's, one byte is\r\n    //  inserted in front of the counter thus making the counter eight bits bigger.\" This is\r\n    //  not currently taken into account]\r\n    //\r\n    // * Counter: 4 octets (at least ..)\r\n    readFrameContent.PCNT = function (view, offset, length) {\r\n        // The counter must be at least 4 octets long to begin with\r\n        if (length < 4) {\r\n            return {}; // Inadequate length!\r\n        }\r\n\r\n        // Assume the counter is always exactly 4 octets ..\r\n        return { counter: view.getUint32(offset) };\r\n    };\r\n\r\n    // Read the content of a [popularimeter](http://id3.org/id3v2.3.0#Popularimeter). Intended\r\n    //  as a measure for the file's popularity, it contains a user's email address, one rating\r\n    //  octet and a four octer play counter, intended to be increased with one for every time\r\n    //  the file is played. If no personal counter is wanted it may be omitted. [As is the case\r\n    //  for the \"PCNT\" frame, according to the standard, \"When the counter reaches all one's,\r\n    //  one byte is inserted in front of the counter thus making the counter eight bits\r\n    //  bigger.\" This is not currently taken into account]. There may be more than one \"POPM\"\r\n    //  frame in each tag, but only one with the same email address\r\n    //\r\n    // * Email to user: a text string (followed by 00)\r\n    // * Rating:        a single octet, values in 0-255 (0 = unknown, 1 = worst, 255 = best)\r\n    // * Counter:       4 octets (at least ..)\r\n    readFrameContent.POPM = function (view, offset, length) {\r\n        var content = {\r\n                email: lib.readTrmStr.iso(view, offset, length)\r\n            };\r\n\r\n        // rating offset\r\n        offset += content.email.length + 1;\r\n\r\n        // email str term + rating + counter = at least 6 octets\r\n        if (length < 6) {\r\n            return content; // Inadequate length!\r\n        }\r\n\r\n        content.rating = view.getUint8(offset);\r\n\r\n        // Assume the counter is always exactly 4 octets ..\r\n        content.counter = view.getUint32(offset + 1);\r\n\r\n        return content;\r\n    };\r\n\r\n    // Read the content of an [attached picture](http://id3.org/id3v2.3.0#Attached_picture).\r\n    //  Contains a picture directly related to the audio file. In the event that the MIME media\r\n    //  type name is omitted, \"image/\" will be implied. The description has a maximum length of\r\n    //  64 characters, but may be empty. There may be several pictures attached to one file,\r\n    //  each in their individual \"APIC\" frame, but only one with the same content descriptor.\r\n    //  There may only be one picture with the picture type declared as picture type $01 and\r\n    //  $02 respectively.\r\n    //\r\n    // * Encoding:     a single octet where 0 = ISO-8859-1, 1 = UCS-2\r\n    // * MIME Type:    a text string (followed by 00) - MIME type and subtype of image\r\n    // * Picture type: a single octet, values in 0-255: a type-id as given by the standard\r\n    // * Description:  a text string according to encoding (followed by 00 (00))\r\n    // * Picture data: binary data (of unbounded length)\r\n    readFrameContent.APIC = function (view, offset, length) {\r\n        // The content to be returned\r\n        var content = { encoding: view.getUint8(offset) };\r\n\r\n        // Encoding + MIME type string term + pic type octet + descr. string term = min 4 octets\r\n        if (length < 4) {\r\n            return content; // Inadequate length!\r\n        }\r\n\r\n        // Encoding and offsets of content beginning / null-terminator\r\n        var enc = content.encoding === 0 ? \"iso\" : \"ucs\";\r\n        var offsetBeg, offsetTrm;\r\n\r\n        // Locate the the null terminator seperating MIME type and picture type\r\n        offsetBeg = offset + 1; // After the encoding octet\r\n        offsetTrm = lib.locateStrTrm.iso(view, offsetBeg, length - 1);\r\n        if (offsetTrm === -1) {\r\n            return content; // Not found!\r\n        }\r\n\r\n        // Read MIME type\r\n        content.mimeType = lib.readStr.iso(view, offsetBeg, offsetTrm - offsetBeg);\r\n\r\n        // Read picture type\r\n        offsetBeg = offsetTrm + 1;\r\n        content.pictureType = view.getUint8(offsetBeg);\r\n\r\n        // Locate the the null terminator seperating description and picture data\r\n        offsetBeg += 1;\r\n        offsetTrm = lib.locateStrTrm[enc](view, offsetBeg, offset + length - offsetBeg);\r\n        if (offsetTrm === -1) {\r\n            return content; // Not found!\r\n        }\r\n\r\n        // Read description\r\n        content.description = lib.readStr[enc](view, offsetBeg, offsetTrm - offsetBeg);\r\n\r\n        // Read picture data\r\n        offsetBeg = offsetTrm + (enc === \"ucs\" ? 2 : 1);\r\n        content.pictureData = new DataView(view.buffer, offsetBeg, offset + length - offsetBeg);\r\n\r\n        return content;\r\n    };\r\n\r\n    // Read the chapter tag according to the ID3v2 Chapter Frame Addendum (http://id3.org/id3v2-chapters-1.0)\r\n    //  The frame contains subframes, typically TIT2, and possibly additional frames\r\n    //\r\n    // * Id:            string identifier of the chapter\r\n    // * Start time:    4 octets specifying the start of the chapter in milliseconds\r\n    // * End time:      4 octets specifying the end of the chapter in milliseconds\r\n    // * Start offset:  4 octets specifying the start of the chapter in bytes\r\n    // * End offset:    4 octets specifying the end of the chapter in bytes\r\n    // * Frames:        nested id3v2 frames\r\n    readFrameContent.CHAP = function (view, offset, length) {\r\n        // The content to be returned\r\n        var content = { encoding: view.getUint8(offset) };\r\n\r\n        // Locate the the null terminator between id and start time\r\n        var offsetTrm = lib.locateStrTrm.iso(view, offset, length - 1);\r\n\r\n        if (offsetTrm === -1) {\r\n            return content; // Not found!\r\n        }\r\n\r\n        // Read id\r\n        content.id = lib.readStr.iso(view, offset, offsetTrm - offset);\r\n\r\n        // Read start time\r\n        content.startTime = view.getUint32(offsetTrm + 1);\r\n\r\n        // Read end time\r\n        content.endTime = view.getUint32(offsetTrm + 5);\r\n\r\n        // Read start offset\r\n        content.startOffset = view.getUint32(offsetTrm + 9);\r\n\r\n        // Read end offset\r\n        content.endOffset = view.getUint32(offsetTrm + 13);\r\n\r\n        var offsetSubFrames = offsetTrm + 17;\r\n        content.frames = [];\r\n        while (offsetSubFrames < offset + length) {\r\n            var subFrame = mp3Id3v2Parser.readId3v2TagFrame(view, offsetSubFrames);\r\n            content.frames.push(subFrame);\r\n            offsetSubFrames += subFrame.header.size + 10;\r\n        }\r\n\r\n        return content;\r\n    };\r\n\r\n    // ### Read an ID3v2 Tag Frame\r\n    //\r\n    // Read [ID3v2 Tag frame](http://id3.org/id3v2.3.0#Declared_ID3v2_frames) located at `offset`\r\n    //  of DataView `view`. Returns null in the event that no tag-frame is found at `offset`\r\n    mp3Id3v2Parser.readId3v2TagFrame = function (view, offset) {\r\n        // All frames consist of a frame header followed by one or more fields containing the actual\r\n        // information. The frame header is 10 octets long and laid out as `IIIISSSSFF`, where\r\n        //\r\n        // * `IIII......`: Frame id (four characters)\r\n        // * `....SSSS..`: Size (frame size excluding frame header = frame size - 10)\r\n        // * `........FF`: Flags\r\n        var frame = {\r\n            header: {\r\n                id: lib.readStr.iso(view, offset, 4),\r\n                size: view.getUint32(offset + 4),\r\n                flagsOctet1: view.getUint8(offset + 8),\r\n                flagsOctet2: view.getUint8(offset + 9)\r\n            }\r\n        };\r\n\r\n        // An ID3v2 tag frame must have a length of at least 1 octet, excluding the header\r\n        if (frame.header.size < 1) { return frame; }\r\n\r\n        // A function to read the frame's content\r\n        var readContent = (function (read, id) { // jscs:disable requirePaddingNewLinesBeforeLineComments\r\n            // User-defined text-information frames\r\n            if (id === \"TXXX\") { return read.TXXX; }\r\n            // Text-information frames\r\n            if (id.charAt(0) === \"T\") { return read.T; }\r\n            // User-defined URL-link frames\r\n            if (id === \"WXXX\") { return read.WXXX; }\r\n            // URL-link frames\r\n            if (id.charAt(0) === \"W\") { return read.W; }\r\n            // Comment frames or Unsychronised lyrics/text transcription frames\r\n            if (id === \"COMM\" || id === \"USLT\") { return read.COMM; }\r\n            // For any other frame such as UFID, IPLS, USER, etc, return the reader function\r\n            //  that's named after the frame. Return a 'no-op reader' (which just returns\r\n            //  `undefined` as the frame's content) if no implementation found for given frame\r\n            return read[id] || lib.noOp;\r\n        }(readFrameContent, frame.header.id)); // jscs-enable requirePaddingNewLinesBeforeLineComments\r\n\r\n        // Store frame's friendly name\r\n        frame.name = id3v2TagFrameNames[frame.header.id];\r\n\r\n        // Read frame's content\r\n        frame.content = readContent(view, offset + 10, frame.header.size);\r\n\r\n        return frame;\r\n    };\r\n\r\n    // ### Read the ID3v2 Tag\r\n    //\r\n    // Read [ID3v2 Tag](http://id3.org/id3v2.3.0) located at `offset` of DataView `view`. Returns\r\n    //  null in the event that no tag is found at `offset`\r\n    mp3Id3v2Parser.readId3v2Tag = function (view, offset) {\r\n        offset || (offset = 0);\r\n\r\n        // The ID3v2 tag header, which should be the first information in the file, is 10 octets\r\n        //  long and laid out as `IIIVVFSSSS`, where\r\n        //\r\n        // * `III.......`: id, always \"ID3\" (0x49/73, 0x44/68, 0x33/51)\r\n        // * `...VV.....`: version (major version + revision number)\r\n        // * `.....F....`: flags: abc00000. a:unsynchronisation, b:extended header, c:experimental\r\n        // * `......SSSS`: tag's size as a synchsafe integer\r\n\r\n        // There should be at least 10 bytes ahead\r\n        if (view.byteLength - offset < 10) { return null; }\r\n\r\n        // The 'ID3' identifier is expected at given offset\r\n        if (!lib.isSeq(lib.seq.id3, view, offset)) { return null; }\r\n\r\n        //\r\n        var flagsOctet = view.getUint8(offset + 5);\r\n\r\n        //\r\n        var tag = {\r\n            _section: { type: \"ID3v2\", offset: offset },\r\n            header: {\r\n                majorVersion: view.getUint8(offset + 3),\r\n                minorRevision: view.getUint8(offset + 4),\r\n                flagsOctet: flagsOctet,\r\n                unsynchronisationFlag: (flagsOctet & 128) === 128,\r\n                extendedHeaderFlag: (flagsOctet & 64) === 64,\r\n                experimentalIndicatorFlag: (flagsOctet & 32) === 32,\r\n                size: lib.unsynchsafe(view.getUint32(offset + 6))\r\n            },\r\n            frames: []\r\n        };\r\n\r\n        // The size as expressed in the header is the size of the complete tag after\r\n        //  unsychronisation, including padding, excluding the header but not excluding the\r\n        //  extended header (total tag size - 10)\r\n        tag._section.byteLength = tag.header.size + 10;\r\n\r\n        // Index of octet following tag's last octet: The tag spans [offset, tagEnd)\r\n        //  (including the first 10 header octets)\r\n        var tagEnd = offset + tag._section.byteLength;\r\n\r\n        // TODO: Process extended header if present. The presence of an extended header will affect\r\n        //  the offset. Currently, it is asummed that no extended header is present so the offset\r\n        //  is fixed at 10 octets\r\n        // if (tag.header.extendedHeaderFlag) { /* TODO */ }\r\n\r\n        // Go on to read individual frames but only if the tag version is v2.3. This is the only\r\n        //  version currently supported\r\n        if (tag.header.majorVersion !== 3) { return tag; }\r\n\r\n        // To store frames as they're discovered while paring the tag\r\n        var frame;\r\n\r\n        // Move offset past the end of the tag header to start reading tag frames\r\n        offset += 10;\r\n        while (offset < tagEnd) {\r\n            // Locating a frame with a zeroed out id indicates that all valid frames have already\r\n            //  been parsed. It's all dead space hereon so practically we're done\r\n            if (view.getUint32(offset) === 0) { break; }\r\n\r\n            frame = mp3Id3v2Parser.readId3v2TagFrame(view, offset);\r\n\r\n            // Couldn't parse this frame so bail out\r\n            if (!frame) { break; }\r\n\r\n            tag.frames.push(frame);\r\n            offset += frame.header.size + 10;\r\n        }\r\n\r\n        return tag;\r\n    };\r\n}));\r\n","//     mp3-parser/xing v0.3.0\r\n\r\n//     https://github.com/biril/mp3-parser\r\n//     Licensed and freely distributed under the MIT License\r\n//     Copyright (c) 2013-2016 Alex Lambiris\r\n\r\n// ----\r\n\r\n/* jshint browser:true */\r\n/* global exports:false, define:false, require:false */\r\n(function (globalObject, createModule) {\r\n    \"use strict\";\r\n\r\n    // Export as a module or global depending on environment:\r\n\r\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\r\n    if (typeof define === \"function\" && define.amd) {\r\n        return define([\"exports\", \"./lib\"], createModule);\r\n    }\r\n\r\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\r\n    if (typeof exports === \"object\") {\r\n        return createModule(exports, require(\"./lib\"));\r\n    }\r\n\r\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\r\n    var previousMp3XingParser = globalObject.mp3XingParser;\r\n    createModule(globalObject.mp3XingParser = {\r\n        noConflict: function () {\r\n            var mp3XingParser = globalObject.mp3XingParser;\r\n            globalObject.mp3XingParser = previousMp3XingParser;\r\n            return (this.noConflict = function () { return mp3XingParser; }).call();\r\n        }\r\n    }, globalObject.mp3ParserLib);\r\n}(this, function (xingParser, lib) {\r\n    \"use strict\";\r\n\r\n    // ### Read the Xing Tag\r\n    //\r\n    // Read [Xing / Lame Tag](http://gabriel.mp3-tech.org/mp3infotag.html) located at `offset` of\r\n    //  DataView `view`. Returns null in the event that no frame is found at `offset`\r\n    xingParser.readXingTag = function (view, offset) {\r\n        offset || (offset = 0);\r\n\r\n        var tag = {\r\n            _section: { type: \"Xing\", offset: offset },\r\n            header: lib.readFrameHeader(view, offset),\r\n            vbrinfo: {},\r\n        };\r\n\r\n        var head = tag.header; // Convenience shortcut\r\n\r\n        // The Xing tag should begin with a valid frame header\r\n        if (!head) { return null; }\r\n\r\n        var xingOffset = offset +\r\n            lib.getXingOffset(head.mpegAudioVersionBits, head.channelModeBits);\r\n\r\n        // There should be at least 'offset' (header) + 4 (\"Xing\"/\"Info\") octets ahead\r\n        if (view.byteLength < xingOffset + 4) { return null; }\r\n\r\n        // A \"Xing\" or \"Info\" identifier should be present\r\n        tag.identifier = (lib.isSeq(lib.seq.xing, view, xingOffset) && \"Xing\") ||\r\n            (lib.isSeq(lib.seq.info, view, xingOffset) && \"Info\");\r\n        if (!tag.identifier) { return null; }\r\n\r\n        // ========== read lame vbr tags (see libmp3lame/VbrTag.c) ==========\r\n        //   \"Xing\"/\"Info\"    4B\r\n        //   flags            4B     big endian; same below\r\n        //   frames           4B     if flags & 0x0001\r\n        //   bytes            4B     if flags & 0x0002\r\n        //   TOC            100B     if flags & 0x0004\r\n        //   vbrscale         4B     if flags & 0x0008\r\n        //   ???             21B\r\n        //   ENC_DELAY      1.5B     (check for reasonable values)\r\n        //   ENC_PADDING    1.5B     (check for reasonable values)\r\n        // ==================================================================\r\n        let vbroffset = 4;\r\n        let flags = view.getUint32(xingOffset + vbroffset);\r\n        vbroffset += 4;\r\n        if (flags & 0x0001) {\r\n            tag.vbrinfo.frames_raw = view.getUint32(xingOffset + vbroffset);\r\n            vbroffset += 4;\r\n        }\r\n        if (flags & 0x0002) {\r\n            tag.vbrinfo.bytes_raw = view.getUint32(xingOffset + vbroffset);\r\n            vbroffset += 4;\r\n        }\r\n        if (flags & 0x0004) {\r\n            tag.vbrinfo.toc_raw = new Array(100);\r\n            for (let i=0; i<100; ++i)\r\n                tag.vbrinfo.toc_raw[i] = view.getUint8(xingOffset + vbroffset + i);\r\n            vbroffset += 100;\r\n        }\r\n        if (flags & 0x0008) {\r\n            tag.vbrinfo.vbr_scale_raw = view.getUint32(xingOffset + vbroffset);\r\n            vbroffset += 4;\r\n        }\r\n        // https://linux.m2osw.com/mp3-info-tag-specifications-rev0-lame-3100\r\n        let lame_version_buffer = new Uint8Array(view.buffer, view.byteOffset + xingOffset + vbroffset, 9);\r\n        tag.vbrinfo.lame_version = String.fromCharCode.apply(null, lame_version_buffer);\r\n        // delay, padding\r\n        vbroffset += 21;\r\n        let t0 = view.getUint8(xingOffset + vbroffset);\r\n        let t1 = view.getUint8(xingOffset + vbroffset + 1);\r\n        let t2 = view.getUint8(xingOffset + vbroffset + 2);\r\n        tag.vbrinfo.ENC_DELAY = (t0<<4)|(t1>>4);\r\n        tag.vbrinfo.ENC_PADDING = ((t1&0x0f)<<8)|t2;\r\n        if (tag.vbrinfo.ENC_DELAY<0 || tag.vbrinfo.ENC_DELAY>3000)\r\n            tag.vbrinfo.ENC_DELAY = -1;\r\n        if (tag.vbrinfo.ENC_PADDING<0 || tag.vbrinfo.ENC_PADDING>3000)\r\n            tag.vbrinfo.ENC_PADDING = -1;\r\n        // =================== read vbr tag ends ===================\r\n\r\n        //\r\n        tag._section.byteLength = lib.getFrameByteLength(head.bitrate, head.samplingRate,\r\n            head.framePadding, head.mpegAudioVersionBits, head.layerDescriptionBits);\r\n        tag._section.nextFrameIndex = offset + tag._section.byteLength;\r\n\r\n        return tag;\r\n    };\r\n}));\r\n","//     mp3-parser v0.3.0\r\n\r\n//     https://github.com/biril/mp3-parser\r\n//     Licensed and freely distributed under the MIT License\r\n//     Copyright (c) 2013-2016 Alex Lambiris\r\n\r\n// ----\r\n\r\n/* jshint browser:true */\r\n/* global exports:false, define:false, require:false */\r\n(function (globalObject, createModule) {\r\n    \"use strict\";\r\n\r\n    // Export as a module or global depending on environment:\r\n\r\n    // Global `define` method with `amd` property signifies an AMD loader (require.js, curl.js, ..)\r\n    if (typeof define === \"function\" && define.amd) {\r\n        return define([\"exports\", \"./lib/lib\", \"./lib/id3v2\", \"./lib/xing\"], createModule);\r\n    }\r\n\r\n    // Global `exports` object signifies CommonJS enviroments with `module.exports`, e.g. Node\r\n    if (typeof exports === \"object\") {\r\n        return createModule(exports, require(\"./lib/lib\"), require(\"./lib/id3v2\"),\r\n            require(\"./lib/xing\"));\r\n    }\r\n\r\n    // If none of the above, then assume a browser sans AMD (also attach a `noConflict`)\r\n    var previousMp3Parser = globalObject.mp3Parser;\r\n    createModule(globalObject.mp3Parser = {\r\n        noConflict: function () {\r\n            var mp3Parser = globalObject.mp3Parser;\r\n            globalObject.mp3Parser = previousMp3Parser;\r\n            return (this.noConflict = function () { return mp3Parser; }).call();\r\n        }\r\n    }, globalObject.mp3ParserLib, globalObject.mp3Id3v2Parser, globalObject.mp3XingParser);\r\n}(this, function (mp3Parser, lib, id3v2Parser, xingParser) {\r\n    \"use strict\";\r\n\r\n    // ### TL;DR\r\n    //\r\n    // The parser exposes a collection of `read____` methods, each dedicated to reading a specific\r\n    //  section of the mp3 file. The current implementation includes `readFrameHeader`, `readFrame`,\r\n    //  `readId3v2Tag` and `readXingTag`. Each of these accepts a DataView-wrapped ArrayBuffer,\r\n    //  which should contain the actual mp3 data, and optionally an offset into the buffer.\r\n    //\r\n    // All methods return a description of the section read in the form of a hash containing\r\n    //  key-value pairs relevant to the section. For example the hash returned from\r\n    //  `readFrameHeader` always contains an `mpegAudioVersion` key of value \"MPEG Version 1\r\n    //  (ISO/IEC 11172-3)\" and a `layerDescription` key of value \"Layer III\". A description will\r\n    //  always have a `_section` hash with `type`, `byteLength` and `offset` keys:\r\n    //\r\n    //  * `type`: \"frame\", \"frameHeader\", \"Xing\" or \"ID3\"\r\n    //  * `byteLenfth`: Size of the section in bytes\r\n    //  * `offset`: Buffer offset at which this section resides\r\n\r\n    // ----\r\n\r\n    // ### Read a Frame Header\r\n    //\r\n    // Read and return description of header of frame located at `offset` of DataView `view`.\r\n    //  Returns `null` in the event that no frame header is found at `offset`\r\n    mp3Parser.readFrameHeader = function (view, offset) {\r\n        return lib.readFrameHeader(view, offset);\r\n    };\r\n\r\n    // ### Read a Frame\r\n    //\r\n    // Read and return description of frame located at `offset` of DataView `view`. Includes the\r\n    //  frame header description (see `readFrameHeader`) plus some basic information about the\r\n    //  frame - notably the frame's length in bytes. If `requireNextFrame` is set, the presence of\r\n    //  a _next_ valid frame will be required for _this_ frame to be regarded as valid. Returns\r\n    //  null in the event that no frame is found at `offset`\r\n    mp3Parser.readFrame = function (view, offset, requireNextFrame) {\r\n        return lib.readFrame(view, offset, requireNextFrame);\r\n    };\r\n\r\n    // ### Read the Last Frame\r\n    //\r\n    // Locate and return description of the very last valid frame in given DataView `view`. The\r\n    //  search is carried out in reverse, from given `offset` (or the very last octet if `offset`\r\n    //  is ommitted) to the first octet in the view. If `requireNextFrame` is set, the presence\r\n    //  of a next valid frame will be required for any found frame to be regarded as valid (causing\r\n    //  the method to essentially return the next-to-last frame on success). Returns `null` in the\r\n    //  event that no frame is found at `offset`\r\n    mp3Parser.readLastFrame = function (view, offset, requireNextFrame) {\r\n        offset || (offset = view.byteLength - 1);\r\n\r\n        var lastFrame = null;\r\n\r\n        for (; offset >= 0; --offset) {\r\n            if (view.getUint8(offset) === 255) {\r\n                // Located a candidate frame as 255 is a possible frame-sync byte\r\n                lastFrame = mp3Parser.readFrame(view, offset, requireNextFrame);\r\n                if (lastFrame) { return lastFrame; }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    // ### Read the ID3v2 Tag\r\n    //\r\n    // Read and return description of [ID3v2 Tag](http://id3.org/id3v2.3.0) located at `offset` of\r\n    //  DataView `view`. (This will include any and all\r\n    //  [currently supported ID3v2 frames](https://github.com/biril/mp3-parser/wiki) located within\r\n    //  the tag). Returns `null` in the event that no tag is found at `offset`\r\n    mp3Parser.readId3v2Tag = function (view, offset) {\r\n        return id3v2Parser.readId3v2Tag(view, offset);\r\n    };\r\n\r\n    // ### Read the Xing Tag\r\n    //\r\n    // Read and return description of\r\n    //  [Xing / Lame Tag](http://gabriel.mp3-tech.org/mp3infotag.html) located at `offset` of\r\n    //  DataView `view`. Returns `null` in the event that no frame is found at `offset`\r\n    mp3Parser.readXingTag = function (view, offset) {\r\n        return xingParser.readXingTag(view, offset);\r\n    };\r\n\r\n    // ### Read all Tags up to First Frame\r\n    // Read and return descriptions of all tags found up to (and including) the very first frame.\r\n    //  Returns an array of sections which may include a description of a located ID3V2 tag, a\r\n    //  description of located Xing / Lame tag and a description of the a located first frame\r\n    //  ( See [this](http://www.rengels.de/computer/mp3tags.html) and\r\n    //  [this](http://stackoverflow.com/a/5013505) )\r\n    // MODIFIED: Bug fix, see: https://github.com/111116/webosu/commit/fe88d078d18955f6d0cd6b02f018ff0098c54901\r\n    mp3Parser.readTags = function (view, offset) {\r\n        offset || (offset = 0);\r\n\r\n        var sections = [];\r\n        var section = null;\r\n        var isFirstFrameFound = false;\r\n        var bufferLength = view.byteLength;\r\n\r\n        var readers = [mp3Parser.readId3v2Tag, mp3Parser.readXingTag, mp3Parser.readFrame];\r\n        var numOfReaders = readers.length;\r\n\r\n        // While we haven't located the first frame, pick the next offset ..\r\n        for (; offset < bufferLength && !isFirstFrameFound; ++offset) {\r\n            // .. and try out each of the 'readers' on it\r\n            for (var i = 0; i < numOfReaders; ++i) {\r\n                section = readers[i](view, offset);\r\n\r\n                // If one of the readers successfully parses a section ..\r\n                if (section && section._section.byteLength) {\r\n                    // .. store it ..\r\n                    sections.push(section);\r\n\r\n                    // .. and push the offset to the very end of end of that section. This way,\r\n                    //  we avoid iterating over offsets which definately aren't the begining of\r\n                    //  some section (they're part of the located section)\r\n                    offset += section._section.byteLength;\r\n\r\n                    // If the section we just parsed is a frame then we've actually located the\r\n                    //  first frame. Break out of the readers-loop making sure to set\r\n                    //  isFirstFrameFound (so that we also exit the outer loop)\r\n                    if (section._section.type === \"frame\") {\r\n                        isFirstFrameFound = true;\r\n                        break;\r\n                    }\r\n\r\n                    // The section is _not_ the first frame. So, having pushed the offset\r\n                    //  appropriately, retry all readers\r\n                    i = -1;\r\n                }\r\n            }\r\n        }\r\n\r\n        return sections;\r\n    };\r\n}));\r\n"],"names":["globalObject","createModule","exports","this","lib","octetToBinRep","b","octet","kbitrate","samplingRate","padding","mpegVersion","layerVersion","sampleLength","paddingSize","byteRate","channelMode","mono","str","seq","value","out","mask","view","offset","i","length","l","trmOffset","buffer","b1","b2","header","b3","b4","requireNextFrame","frame","head","xingOffset","require$$0","mp3Id3v2Parser","id3v2TagFrameNames","readFrameContent","content","enc","offsetBeg","offsetTrm","ownerIdentifier","identifier","offsetNextStrTrm","privateData","offsetSubFrames","subFrame","readContent","read","id","flagsOctet","tag","tagEnd","xingParser","vbroffset","flags","lame_version_buffer","t0","t1","t2","require$$1","require$$2","mp3Parser","id3v2Parser","lastFrame","sections","section","isFirstFrameFound","bufferLength","readers","numOfReaders"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}